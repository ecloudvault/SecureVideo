package com.oscgc.securevideo.server.tool;import com.oscgc.securevideo.server.model.ExecuteResult;import com.oscgc.securevideo.server.model.StreamGobbler;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.*;import java.util.concurrent.*;/** * Created by Yq on 2015/6/4. */public class CommandUtils {        static final Logger logger = LoggerFactory.getLogger(CommandUtils.class);        static ExecutorService pool = new ThreadPoolExecutor(0,                                                         Integer.MAX_VALUE,                                                         3L,                                                         TimeUnit.SECONDS,                                                         new SynchronousQueue<Runnable>());        public static ExecuteResult executeCommand(String[] command, long timeout) {        Process process = null;        InputStream pIn = null;        InputStream pErr = null;        StreamGobbler outputGobbler = null;        StreamGobbler errorGobbler = null;        Future<Integer> executeFuture = null;        try {            process = Runtime.getRuntime().exec(command);            final Process p = process;                        // close process's output stream.            p.getOutputStream().close();                        pIn = process.getInputStream();            outputGobbler = new StreamGobbler(pIn, "OUTPUT");            outputGobbler.start();                        pErr = process.getErrorStream();            errorGobbler = new StreamGobbler(pErr, "ERROR");            errorGobbler.start();                        InputStreamReader ir = new InputStreamReader(process.getInputStream());            LineNumberReader input = new LineNumberReader(ir);            String line;            logger.debug(" start exec shell command!!");            while ((line = input.readLine()) != null) {                logger.debug(line);            }            logger.debug(" end  command!!");                        // create a Callable for the command's Process which can be called            // by an Executor            Callable<Integer> call = new Callable<Integer>() {                public Integer call() throws Exception {                    p.waitFor();                    return p.exitValue();                }            };                        // submit the command's call and get the result from a            executeFuture = pool.submit(call);            int exitCode = executeFuture.get(timeout, TimeUnit.MILLISECONDS);            return new ExecuteResult(exitCode, outputGobbler.getContent());                    }        catch (IOException ex) {            String errorMessage = "The command [" + command                                  + "] execute failed.";            logger.error(errorMessage, ex);            return new ExecuteResult(-1, null);        }        catch (TimeoutException ex) {            String errorMessage = "The command [" + command + "] timed out.";            logger.error(errorMessage, ex);            return new ExecuteResult(-1, null);        }        catch (ExecutionException ex) {            String errorMessage = "The command [" + command                                  + "] did not complete due to an execution error.";            logger.error(errorMessage, ex);            return new ExecuteResult(-1, null);        }        catch (InterruptedException ex) {            String errorMessage = "The command [" + command                                  + "] did not complete due to an interrupted error.";            logger.error(errorMessage, ex);            return new ExecuteResult(-1, null);        }        finally {            if (executeFuture != null) {                try {                    executeFuture.cancel(true);                }                catch (Exception ignore) {                }            }            if (pIn != null) {                closeQuietly(pIn);                if (outputGobbler != null && !outputGobbler.isInterrupted()) {                    outputGobbler.interrupt();                }            }            if (pErr != null) {                closeQuietly(pErr);                if (errorGobbler != null && !errorGobbler.isInterrupted()) {                    errorGobbler.interrupt();                }            }            if (process != null) {                process.destroy();            }        }    }        public static void closeQuietly(Closeable c) {        try {            if (c != null)                c.close();        }        catch (IOException e) {        }    }}