package com.oscgc.securevideo.server.tool.rsa;import java.io.IOException;import java.io.StringWriter;import java.security.*;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.InvalidKeySpecException;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import org.bouncycastle.openssl.PEMWriter;import org.bouncycastle.util.encoders.Base64;import org.bouncycastle.util.io.pem.PemObject;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.NoSuchPaddingException;/** * Created by Yq on 2015/6/10. */public class RsaKeyTools {        public static final String PEM_PUBLICKEY = "PUBLIC KEY";        public static final String PEM_PRIVATEKEY = "PRIVATE KEY";        public static final String KEY_ALGORITHM = "RSA";        public static final String ENCRYPT_TYPT = "SHA1WithRSA";        public static final String KEY_PROVIDER = "BC";        /**     * generateRSAKeyPair     *      * @param keySize     * @return     */    public static KeyPair generateRSAKeyPair(int keySize) {        KeyPairGenerator generator = null;        SecureRandom random = new SecureRandom();        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());        try {            generator = KeyPairGenerator.getInstance(KEY_ALGORITHM,                                                     KEY_PROVIDER);        }        catch (NoSuchAlgorithmException e) {            e.printStackTrace();        }        catch (NoSuchProviderException e) {            e.printStackTrace();        }                generator.initialize(keySize, random);                KeyPair keyPair = generator.generateKeyPair();                return keyPair;    }        /**     * convertToPemKey     *      * @param publicKey     * @param privateKey     * @return     */    public static String convertToPemKey(RSAPublicKey publicKey,                                         RSAPrivateKey privateKey) {        if (publicKey == null && privateKey == null) {            return null;        }        StringWriter stringWriter = new StringWriter();                try {            PEMWriter pemWriter = new PEMWriter(stringWriter, KEY_PROVIDER);                        if (publicKey != null) {                                pemWriter.writeObject(new PemObject(PEM_PUBLICKEY,                                                    publicKey.getEncoded()));            }            else {                pemWriter.writeObject(new PemObject(PEM_PRIVATEKEY,                                                    privateKey.getEncoded()));            }            pemWriter.flush();        }        catch (IOException e) {            e.printStackTrace();        }        return stringWriter.toString();    }        public static byte[] sign(String data, byte[] privateKey) throws Exception {        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(privateKey);                KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);                PrivateKey privateKey2 = keyFactory.generatePrivate(pkcs8EncodedKeySpec);        Signature signature = Signature.getInstance(ENCRYPT_TYPT);        signature.initSign(privateKey2);        signature.update(data.getBytes());        return signature.sign();            }        public static boolean verify(String data,                                 byte[] publicKey,                                 byte[] signatureResult) {        try {            X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(publicKey);            KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);            PublicKey publicKey2 = keyFactory.generatePublic(x509EncodedKeySpec);                        Signature signature = Signature.getInstance(ENCRYPT_TYPT);            signature.initVerify(publicKey2);            signature.update(data.getBytes());                        return signature.verify(signatureResult);        }        catch (Exception e) {            e.printStackTrace();        }        return false;    }        public static byte[] decryptByPrivateKey(byte[] data, byte[] keyBytes) throws Exception {        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);        Key privateKey = keyFactory.generatePrivate(pkcs8KeySpec);                Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());        cipher.init(Cipher.DECRYPT_MODE, privateKey);                return cipher.doFinal(data);    }        public static byte[] encryptByPublicKey(String data, byte[] keyBytes) {                X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);        KeyFactory keyFactory = null;        byte[] resultByte = null;        try {            keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);            Key publicKey = keyFactory.generatePublic(x509KeySpec);                        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());            cipher.init(Cipher.ENCRYPT_MODE, publicKey);            resultByte = cipher.doFinal(data.getBytes());        }        catch (NoSuchAlgorithmException e) {            e.printStackTrace();        }        catch (IllegalBlockSizeException e) {            e.printStackTrace();        }        catch (InvalidKeyException e) {            e.printStackTrace();        }        catch (BadPaddingException e) {            e.printStackTrace();        }        catch (InvalidKeySpecException e) {            e.printStackTrace();        }        catch (NoSuchPaddingException e) {            e.printStackTrace();        }                return resultByte;    }        private static String bytes2String(byte[] bytes) {        StringBuilder string = new StringBuilder();        for (byte b : bytes) {            String hexString = Integer.toHexString(0x00FF & b);            string.append(hexString.length() == 1 ? "0" + hexString : hexString);        }        return string.toString();    }        public static byte[] hexStringToByteArray(String data) {        int k = 0;        byte[] results = new byte[data.length() / 2];        for (int i = 0; i + 1 < data.length(); i += 2, k++) {            results[k] = (byte) (Character.digit(data.charAt(i), 16) << 4);            results[k] += (byte) (Character.digit(data.charAt(i + 1), 16));        }        return results;    }        public static void main(String[] args) {        String str = "coder";        KeyPair k = generateRSAKeyPair(1024);                String publicKey = convertToPemKey((RSAPublicKey) k.getPublic(), null);        String privateKey = convertToPemKey(null,                                            (RSAPrivateKey) k.getPrivate());                // System.out.println("publicKey__\n" + publicKey);        System.out.println("privateKey_\n" + privateKey);                try {            byte[] signautreResult = sign(str, k.getPrivate().getEncoded());            String signatureStr = bytes2String(signautreResult);            byte[] signatureResult2 = hexStringToByteArray(signatureStr);            boolean b = verify(str,                               k.getPublic().getEncoded(),                               signatureResult2);            System.out.println("signinResult:   " + b);                        byte[] enres = encryptByPublicKey(str, k.getPublic().getEncoded());            System.out.println("enResult---:" + new String(Base64.encode(enres)));                        String decry = new String(decryptByPrivateKey(enres, k.getPrivate()                                                                  .getEncoded()));            System.out.println("decrypt:" + decry);                    }        catch (Exception e) {            e.printStackTrace();        }            }    }